// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/leaderberry/schema/evidence.cram

package leaderberry

import (
	"github.com/blockberries/cramberry/pkg/cramberry"
)



// EvidenceType identifies the type of Byzantine behavior
type EvidenceType int32

const (
	EvidenceTypeEvidenceTypeUnknown EvidenceType = 0
	EvidenceTypeEvidenceTypeDuplicateVote EvidenceType = 1
	EvidenceTypeEvidenceTypeLightClientAttack EvidenceType = 2
)

// String returns the string representation of the enum value.
func (e EvidenceType) String() string {
	switch e {
	case EvidenceTypeEvidenceTypeUnknown:
		return "EVIDENCE_TYPE_UNKNOWN"
	case EvidenceTypeEvidenceTypeDuplicateVote:
		return "EVIDENCE_TYPE_DUPLICATE_VOTE"
	case EvidenceTypeEvidenceTypeLightClientAttack:
		return "EVIDENCE_TYPE_LIGHT_CLIENT_ATTACK"
	default:
		return "UNKNOWN"
	}
}

// IsValid returns true if the value is a valid enum value.
func (e EvidenceType) IsValid() bool {
	switch e {
	case EvidenceTypeEvidenceTypeUnknown:
		return true
	case EvidenceTypeEvidenceTypeDuplicateVote:
		return true
	case EvidenceTypeEvidenceTypeLightClientAttack:
		return true
	default:
		return false
	}
}

// EncodeTo encodes the enum value directly to the writer.
func (e EvidenceType) EncodeTo(w *cramberry.Writer) {
	w.WriteInt32(int32(e))
}

// DecodeFrom decodes the enum value from the reader.
func (e *EvidenceType) DecodeFrom(r *cramberry.Reader) {
	*e = EvidenceType(r.ReadInt32())
}


// DuplicateVoteEvidence proves a validator voted twice at the same H/R/S
type DuplicateVoteEvidence struct {
VoteA Vote `cramberry:"1,required" json:"vote_a"`
VoteB Vote `cramberry:"2,required" json:"vote_b"`
TotalVotingPower int64 `cramberry:"3" json:"total_voting_power"`
ValidatorPower int64 `cramberry:"4" json:"validator_power"`
Timestamp int64 `cramberry:"5" json:"timestamp"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *DuplicateVoteEvidence) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *DuplicateVoteEvidence) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.VoteA.EncodeTo(w)
	w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
	m.VoteB.EncodeTo(w)
	if m.TotalVotingPower != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.TotalVotingPower)
	}
	if m.ValidatorPower != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.ValidatorPower)
	}
	if m.Timestamp != 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Timestamp)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *DuplicateVoteEvidence) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *DuplicateVoteEvidence) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.VoteA.DecodeFrom(r)
		case 2:
			m.VoteB.DecodeFrom(r)
		case 3:
			m.TotalVotingPower = r.ReadInt64()
		case 4:
			m.ValidatorPower = r.ReadInt64()
		case 5:
			m.Timestamp = r.ReadInt64()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *DuplicateVoteEvidence) Validate() error {
	return nil
}


// Evidence is a polymorphic evidence container
type Evidence struct {
Type EvidenceType `cramberry:"1" json:"type"`
Height int64 `cramberry:"2" json:"height"`
Time int64 `cramberry:"3" json:"time"`
	// Serialized evidence data (type-specific)
Data []byte `cramberry:"4" json:"data"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Evidence) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Evidence) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.Type.EncodeTo(w)
	if m.Height != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	if m.Time != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Time)
	}
	if len(m.Data) > 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Data)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Evidence) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Evidence) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Type.DecodeFrom(r)
		case 2:
			m.Height = r.ReadInt64()
		case 3:
			m.Time = r.ReadInt64()
		case 4:
			m.Data = r.ReadBytes()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}



