// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/leaderberry/schema/wal.cram

package leaderberry

import (
	"github.com/blockberries/cramberry/pkg/cramberry"
)



// WALMsgType identifies WAL message types
type WalmsgType int32

const (
	WalmsgTypeWalMsgUnknown WalmsgType = 0
	WalmsgTypeWalMsgProposal WalmsgType = 1
	WalmsgTypeWalMsgVote WalmsgType = 2
	WalmsgTypeWalMsgCommit WalmsgType = 3
	WalmsgTypeWalMsgEndHeight WalmsgType = 4
	WalmsgTypeWalMsgState WalmsgType = 5
	WalmsgTypeWalMsgTimeout WalmsgType = 6
)

// String returns the string representation of the enum value.
func (e WalmsgType) String() string {
	switch e {
	case WalmsgTypeWalMsgUnknown:
		return "WAL_MSG_UNKNOWN"
	case WalmsgTypeWalMsgProposal:
		return "WAL_MSG_PROPOSAL"
	case WalmsgTypeWalMsgVote:
		return "WAL_MSG_VOTE"
	case WalmsgTypeWalMsgCommit:
		return "WAL_MSG_COMMIT"
	case WalmsgTypeWalMsgEndHeight:
		return "WAL_MSG_END_HEIGHT"
	case WalmsgTypeWalMsgState:
		return "WAL_MSG_STATE"
	case WalmsgTypeWalMsgTimeout:
		return "WAL_MSG_TIMEOUT"
	default:
		return "UNKNOWN"
	}
}

// IsValid returns true if the value is a valid enum value.
func (e WalmsgType) IsValid() bool {
	switch e {
	case WalmsgTypeWalMsgUnknown:
		return true
	case WalmsgTypeWalMsgProposal:
		return true
	case WalmsgTypeWalMsgVote:
		return true
	case WalmsgTypeWalMsgCommit:
		return true
	case WalmsgTypeWalMsgEndHeight:
		return true
	case WalmsgTypeWalMsgState:
		return true
	case WalmsgTypeWalMsgTimeout:
		return true
	default:
		return false
	}
}

// EncodeTo encodes the enum value directly to the writer.
func (e WalmsgType) EncodeTo(w *cramberry.Writer) {
	w.WriteInt32(int32(e))
}

// DecodeFrom decodes the enum value from the reader.
func (e *WalmsgType) DecodeFrom(r *cramberry.Reader) {
	*e = WalmsgType(r.ReadInt32())
}

// RoundStepType identifies consensus round steps
type RoundStepType int32

const (
	RoundStepTypeRoundStepNewHeight RoundStepType = 0
	RoundStepTypeRoundStepNewRound RoundStepType = 1
	RoundStepTypeRoundStepPropose RoundStepType = 2
	RoundStepTypeRoundStepPrevote RoundStepType = 3
	RoundStepTypeRoundStepPrevoteWait RoundStepType = 4
	RoundStepTypeRoundStepPrecommit RoundStepType = 5
	RoundStepTypeRoundStepPrecommitWait RoundStepType = 6
	RoundStepTypeRoundStepCommit RoundStepType = 7
)

// String returns the string representation of the enum value.
func (e RoundStepType) String() string {
	switch e {
	case RoundStepTypeRoundStepNewHeight:
		return "ROUND_STEP_NEW_HEIGHT"
	case RoundStepTypeRoundStepNewRound:
		return "ROUND_STEP_NEW_ROUND"
	case RoundStepTypeRoundStepPropose:
		return "ROUND_STEP_PROPOSE"
	case RoundStepTypeRoundStepPrevote:
		return "ROUND_STEP_PREVOTE"
	case RoundStepTypeRoundStepPrevoteWait:
		return "ROUND_STEP_PREVOTE_WAIT"
	case RoundStepTypeRoundStepPrecommit:
		return "ROUND_STEP_PRECOMMIT"
	case RoundStepTypeRoundStepPrecommitWait:
		return "ROUND_STEP_PRECOMMIT_WAIT"
	case RoundStepTypeRoundStepCommit:
		return "ROUND_STEP_COMMIT"
	default:
		return "UNKNOWN"
	}
}

// IsValid returns true if the value is a valid enum value.
func (e RoundStepType) IsValid() bool {
	switch e {
	case RoundStepTypeRoundStepNewHeight:
		return true
	case RoundStepTypeRoundStepNewRound:
		return true
	case RoundStepTypeRoundStepPropose:
		return true
	case RoundStepTypeRoundStepPrevote:
		return true
	case RoundStepTypeRoundStepPrevoteWait:
		return true
	case RoundStepTypeRoundStepPrecommit:
		return true
	case RoundStepTypeRoundStepPrecommitWait:
		return true
	case RoundStepTypeRoundStepCommit:
		return true
	default:
		return false
	}
}

// EncodeTo encodes the enum value directly to the writer.
func (e RoundStepType) EncodeTo(w *cramberry.Writer) {
	w.WriteInt32(int32(e))
}

// DecodeFrom decodes the enum value from the reader.
func (e *RoundStepType) DecodeFrom(r *cramberry.Reader) {
	*e = RoundStepType(r.ReadInt32())
}


// WALMessage is a write-ahead log entry
type Walmessage struct {
Type WalmsgType `cramberry:"1" json:"type"`
Height int64 `cramberry:"2" json:"height"`
Round int32 `cramberry:"3" json:"round"`
	// Serialized message data (type-specific)
Data []byte `cramberry:"4" json:"data"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Walmessage) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Walmessage) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.Type.EncodeTo(w)
	if m.Height != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	if m.Round != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Round)
	}
	if len(m.Data) > 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Data)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Walmessage) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Walmessage) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Type.DecodeFrom(r)
		case 2:
			m.Height = r.ReadInt64()
		case 3:
			m.Round = r.ReadInt32()
		case 4:
			m.Data = r.ReadBytes()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}


// EndHeightMessage marks the end of a height in WAL
type EndHeightMessage struct {
Height int64 `cramberry:"1" json:"height"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EndHeightMessage) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *EndHeightMessage) EncodeTo(w *cramberry.Writer) {
	if m.Height != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *EndHeightMessage) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *EndHeightMessage) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Height = r.ReadInt64()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}


// TimeoutMessage records a timeout event
type TimeoutMessage struct {
Height int64 `cramberry:"1" json:"height"`
Round int32 `cramberry:"2" json:"round"`
Step RoundStepType `cramberry:"3" json:"step"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TimeoutMessage) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *TimeoutMessage) EncodeTo(w *cramberry.Writer) {
	if m.Height != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	if m.Round != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Round)
	}
	w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
	m.Step.EncodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *TimeoutMessage) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *TimeoutMessage) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Height = r.ReadInt64()
		case 2:
			m.Round = r.ReadInt32()
		case 3:
			m.Step.DecodeFrom(r)
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}


// ConsensusStateData is the serializable consensus state for WAL
type ConsensusStateData struct {
Height int64 `cramberry:"1" json:"height"`
Round int32 `cramberry:"2" json:"round"`
Step RoundStepType `cramberry:"3" json:"step"`
LockedRound int32 `cramberry:"4" json:"locked_round"`
LockedBlockHash *Hash `cramberry:"5" json:"locked_block_hash"`
ValidRound int32 `cramberry:"6" json:"valid_round"`
ValidBlockHash *Hash `cramberry:"7" json:"valid_block_hash"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ConsensusStateData) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *ConsensusStateData) EncodeTo(w *cramberry.Writer) {
	if m.Height != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	if m.Round != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Round)
	}
	w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
	m.Step.EncodeTo(w)
	if m.LockedRound != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.LockedRound)
	}
	if m.LockedBlockHash != nil {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		m.LockedBlockHash.EncodeTo(w)
	}
	if m.ValidRound != 0 {
		w.WriteCompactTag(6, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.ValidRound)
	}
	if m.ValidBlockHash != nil {
		w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
		m.ValidBlockHash.EncodeTo(w)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *ConsensusStateData) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *ConsensusStateData) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Height = r.ReadInt64()
		case 2:
			m.Round = r.ReadInt32()
		case 3:
			m.Step.DecodeFrom(r)
		case 4:
			m.LockedRound = r.ReadInt32()
		case 5:
			{
			var v Hash
			v.DecodeFrom(r)
			m.LockedBlockHash = &v
		}
		case 6:
			m.ValidRound = r.ReadInt32()
		case 7:
			{
			var v Hash
			v.DecodeFrom(r)
			m.ValidBlockHash = &v
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}


// LastSignState tracks the last signed vote for double-sign prevention
type LastSignState struct {
Height int64 `cramberry:"1" json:"height"`
Round int32 `cramberry:"2" json:"round"`
Step int8 `cramberry:"3" json:"step"`
BlockHash *Hash `cramberry:"4" json:"block_hash"`
Signature Signature `cramberry:"5" json:"signature"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *LastSignState) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *LastSignState) EncodeTo(w *cramberry.Writer) {
	if m.Height != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	if m.Round != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Round)
	}
	if m.Step != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2SVarint)
		w.WriteInt8(m.Step)
	}
	if m.BlockHash != nil {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		m.BlockHash.EncodeTo(w)
	}
	w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
	m.Signature.EncodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *LastSignState) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *LastSignState) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Height = r.ReadInt64()
		case 2:
			m.Round = r.ReadInt32()
		case 3:
			m.Step = r.ReadInt8()
		case 4:
			{
			var v Hash
			v.DecodeFrom(r)
			m.BlockHash = &v
		}
		case 5:
			m.Signature.DecodeFrom(r)
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}



