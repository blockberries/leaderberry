// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/leaderberry/schema/proposal.cram

package leaderberry

import (
	"github.com/blockberries/cramberry/pkg/cramberry"
)




// Proposal is a block proposal from the round's proposer
type Proposal struct {
Height int64 `cramberry:"1" json:"height"`
Round int32 `cramberry:"2" json:"round"`
Timestamp int64 `cramberry:"3" json:"timestamp"`
	// The proposed block
Block Block `cramberry:"4,required" json:"block"`
	// Proof-of-Lock round (-1 if none)
PolRound int32 `cramberry:"5" json:"pol_round"`
	// 2/3+ prevotes from POLRound (empty if pol_round == -1)
PolVotes []Vote `cramberry:"6" json:"pol_votes"`
	// Proposer identification
Proposer AccountName `cramberry:"7,required" json:"proposer"`
Signature Signature `cramberry:"8" json:"signature"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Proposal) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Proposal) EncodeTo(w *cramberry.Writer) {
	if m.Height != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	if m.Round != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.Round)
	}
	if m.Timestamp != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Timestamp)
	}
	w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
	m.Block.EncodeTo(w)
	if m.PolRound != 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2SVarint)
		w.WriteInt32(m.PolRound)
	}
	if len(m.PolVotes) > 0 {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.PolVotes)))
		for _, v := range m.PolVotes {
			v.EncodeTo(w)
		}
	}
	w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
	m.Proposer.EncodeTo(w)
	w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
	m.Signature.EncodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Proposal) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Proposal) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Height = r.ReadInt64()
		case 2:
			m.Round = r.ReadInt32()
		case 3:
			m.Timestamp = r.ReadInt64()
		case 4:
			m.Block.DecodeFrom(r)
		case 5:
			m.PolRound = r.ReadInt32()
		case 6:
			n := int(r.ReadUvarint())
		m.PolVotes = make([]Vote, n)
		for i := 0; i < n; i++ {
			m.PolVotes[i].DecodeFrom(r)
		}
		case 7:
			m.Proposer.DecodeFrom(r)
		case 8:
			m.Signature.DecodeFrom(r)
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *Proposal) Validate() error {
	return nil
}



