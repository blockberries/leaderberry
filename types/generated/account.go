// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/leaderberry/schema/account.cram

package leaderberry

import (
	"github.com/blockberries/cramberry/pkg/cramberry"
)




// KeyWeight associates a public key with a weight for multi-sig
type KeyWeight struct {
PublicKey PublicKey `cramberry:"1,required" json:"public_key"`
Weight uint32 `cramberry:"2" json:"weight"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *KeyWeight) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *KeyWeight) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.PublicKey.EncodeTo(w)
	if m.Weight != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Varint)
		w.WriteUint32(m.Weight)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *KeyWeight) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *KeyWeight) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.PublicKey.DecodeFrom(r)
		case 2:
			m.Weight = r.ReadUint32()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *KeyWeight) Validate() error {
	return nil
}


// AccountWeight associates an account with a weight for delegation
type AccountWeight struct {
Account AccountName `cramberry:"1,required" json:"account"`
Weight uint32 `cramberry:"2" json:"weight"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AccountWeight) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *AccountWeight) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.Account.EncodeTo(w)
	if m.Weight != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Varint)
		w.WriteUint32(m.Weight)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AccountWeight) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *AccountWeight) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Account.DecodeFrom(r)
		case 2:
			m.Weight = r.ReadUint32()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *AccountWeight) Validate() error {
	return nil
}


// Authority defines multi-sig requirements for an account
type Authority struct {
	// Minimum weight required to authorize
Threshold uint32 `cramberry:"1" json:"threshold"`
	// Direct key authorizations
Keys []KeyWeight `cramberry:"2" json:"keys"`
	// Delegated account authorizations
Accounts []AccountWeight `cramberry:"3" json:"accounts"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Authority) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Authority) EncodeTo(w *cramberry.Writer) {
	if m.Threshold != 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Varint)
		w.WriteUint32(m.Threshold)
	}
	if len(m.Keys) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Keys)))
		for _, v := range m.Keys {
			v.EncodeTo(w)
		}
	}
	if len(m.Accounts) > 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Accounts)))
		for _, v := range m.Accounts {
			v.EncodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Authority) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Authority) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Threshold = r.ReadUint32()
		case 2:
			n := int(r.ReadUvarint())
		m.Keys = make([]KeyWeight, n)
		for i := 0; i < n; i++ {
			m.Keys[i].DecodeFrom(r)
		}
		case 3:
			n := int(r.ReadUvarint())
		m.Accounts = make([]AccountWeight, n)
		for i := 0; i < n; i++ {
			m.Accounts[i].DecodeFrom(r)
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}


// Account represents a named account with multi-sig authority
type Account struct {
Name AccountName `cramberry:"1,required" json:"name"`
Id uint64 `cramberry:"2" json:"id"`
Authority Authority `cramberry:"3,required" json:"authority"`
CreatedAt int64 `cramberry:"4" json:"created_at"`
UpdatedAt int64 `cramberry:"5" json:"updated_at"`
Metadata map[string][]byte `cramberry:"6" json:"metadata"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Account) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Account) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.Name.EncodeTo(w)
	if m.Id != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.Id)
	}
	w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
	m.Authority.EncodeTo(w)
	if m.CreatedAt != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.CreatedAt)
	}
	if m.UpdatedAt != 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.UpdatedAt)
	}
	if m.Metadata != nil {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Metadata)))
		for k, v := range m.Metadata {
			w.WriteString(k)
			w.WriteBytes(v)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Account) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Account) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Name.DecodeFrom(r)
		case 2:
			m.Id = r.ReadUint64()
		case 3:
			m.Authority.DecodeFrom(r)
		case 4:
			m.CreatedAt = r.ReadInt64()
		case 5:
			m.UpdatedAt = r.ReadInt64()
		case 6:
			n := int(r.ReadUvarint())
		m.Metadata = make(map[string][]byte, n)
		for i := 0; i < n; i++ {
			var k string
			k = r.ReadString()
			var v []byte
			v = r.ReadBytes()
			m.Metadata[k] = v
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *Account) Validate() error {
	return nil
}



