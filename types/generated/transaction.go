// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/leaderberry/schema/transaction.cram

package leaderberry

import (
	"github.com/blockberries/cramberry/pkg/cramberry"
)




// SignatureProof is a direct signature from a key
type SignatureProof struct {
PublicKey PublicKey `cramberry:"1,required" json:"public_key"`
Signature Signature `cramberry:"2,required" json:"signature"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignatureProof) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *SignatureProof) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.PublicKey.EncodeTo(w)
	w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
	m.Signature.EncodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *SignatureProof) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *SignatureProof) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.PublicKey.DecodeFrom(r)
		case 2:
			m.Signature.DecodeFrom(r)
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *SignatureProof) Validate() error {
	return nil
}


// AccountAuthorization is a delegated authorization from another account
type AccountAuthorization struct {
	// The account providing authorization
Account AccountName `cramberry:"1,required" json:"account"`
	// That account's authorization (recursive)
Authorization Authorization `cramberry:"2,required" json:"authorization"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AccountAuthorization) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *AccountAuthorization) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.Account.EncodeTo(w)
	w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
	m.Authorization.EncodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *AccountAuthorization) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *AccountAuthorization) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Account.DecodeFrom(r)
		case 2:
			m.Authorization.DecodeFrom(r)
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *AccountAuthorization) Validate() error {
	return nil
}


// Authorization provides hierarchical proof of authority
type Authorization struct {
	// Direct signatures from keys
Signatures []SignatureProof `cramberry:"1" json:"signatures"`
	// Delegated authorizations from accounts
AccountAuthorizations []AccountAuthorization `cramberry:"2" json:"account_authorizations"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Authorization) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Authorization) EncodeTo(w *cramberry.Writer) {
	if len(m.Signatures) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Signatures)))
		for _, v := range m.Signatures {
			v.EncodeTo(w)
		}
	}
	if len(m.AccountAuthorizations) > 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.AccountAuthorizations)))
		for _, v := range m.AccountAuthorizations {
			v.EncodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Authorization) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Authorization) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := int(r.ReadUvarint())
		m.Signatures = make([]SignatureProof, n)
		for i := 0; i < n; i++ {
			m.Signatures[i].DecodeFrom(r)
		}
		case 2:
			n := int(r.ReadUvarint())
		m.AccountAuthorizations = make([]AccountAuthorization, n)
		for i := 0; i < n; i++ {
			m.AccountAuthorizations[i].DecodeFrom(r)
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}


// Transaction wraps an opaque payload with authorization metadata.
// The consensus engine verifies authorizations but does not interpret the payload.
type Transaction struct {
	// Opaque payload - interpreted by application layer, not consensus
Payload []byte `cramberry:"1,required" json:"payload"`
	// Account authorizing this transaction
Account AccountName `cramberry:"2,required" json:"account"`
	// Proof of authorization (signatures, delegations)
Authorization Authorization `cramberry:"3,required" json:"authorization"`
	// Sequence number for replay protection
Nonce uint64 `cramberry:"4" json:"nonce"`
	// Unix timestamp after which tx is invalid (optional)
Expiration int64 `cramberry:"5" json:"expiration"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Transaction) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Transaction) EncodeTo(w *cramberry.Writer) {
	if len(m.Payload) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteBytes(m.Payload)
	}
	w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
	m.Account.EncodeTo(w)
	w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
	m.Authorization.EncodeTo(w)
	if m.Nonce != 0 {
		w.WriteCompactTag(4, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.Nonce)
	}
	if m.Expiration != 0 {
		w.WriteCompactTag(5, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Expiration)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Transaction) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Transaction) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Payload = r.ReadBytes()
		case 2:
			m.Account.DecodeFrom(r)
		case 3:
			m.Authorization.DecodeFrom(r)
		case 4:
			m.Nonce = r.ReadUint64()
		case 5:
			m.Expiration = r.ReadInt64()
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *Transaction) Validate() error {
	return nil
}



