// Code generated by cramberry. DO NOT EDIT.
// Source: /Volumes/Tendermint/stealth/leaderberry/schema/block.cram

package leaderberry

import (
	"github.com/blockberries/cramberry/pkg/cramberry"
)




// BatchCertRef references a Looseberry batch certificate
type BatchCertRef struct {
CertificateDigest Hash `cramberry:"1,required" json:"certificate_digest"`
Round uint64 `cramberry:"2" json:"round"`
Validator AccountName `cramberry:"3,required" json:"validator"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BatchCertRef) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *BatchCertRef) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.CertificateDigest.EncodeTo(w)
	if m.Round != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.Round)
	}
	w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
	m.Validator.EncodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BatchCertRef) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *BatchCertRef) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.CertificateDigest.DecodeFrom(r)
		case 2:
			m.Round = r.ReadUint64()
		case 3:
			m.Validator.DecodeFrom(r)
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *BatchCertRef) Validate() error {
	return nil
}


// BlockHeader contains block metadata
type BlockHeader struct {
	// Chain identity
ChainId string `cramberry:"1" json:"chain_id"`
Height int64 `cramberry:"2" json:"height"`
Time int64 `cramberry:"3" json:"time"`
	// Previous block
LastBlockHash *Hash `cramberry:"4" json:"last_block_hash"`
LastCommitHash *Hash `cramberry:"5" json:"last_commit_hash"`
	// State roots
ValidatorsHash *Hash `cramberry:"6" json:"validators_hash"`
AppHash *Hash `cramberry:"7" json:"app_hash"`
ConsensusHash *Hash `cramberry:"8" json:"consensus_hash"`
	// DAG mempool integration
DagRound uint64 `cramberry:"9" json:"dag_round"`
BatchCertRefs []BatchCertRef `cramberry:"10" json:"batch_cert_refs"`
	// Proposer - identified by name
Proposer AccountName `cramberry:"11,required" json:"proposer"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlockHeader) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *BlockHeader) EncodeTo(w *cramberry.Writer) {
	if m.ChainId != "" {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteString(m.ChainId)
	}
	if m.Height != 0 {
		w.WriteCompactTag(2, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Height)
	}
	if m.Time != 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2SVarint)
		w.WriteInt64(m.Time)
	}
	if m.LastBlockHash != nil {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		m.LastBlockHash.EncodeTo(w)
	}
	if m.LastCommitHash != nil {
		w.WriteCompactTag(5, cramberry.WireTypeV2Bytes)
		m.LastCommitHash.EncodeTo(w)
	}
	if m.ValidatorsHash != nil {
		w.WriteCompactTag(6, cramberry.WireTypeV2Bytes)
		m.ValidatorsHash.EncodeTo(w)
	}
	if m.AppHash != nil {
		w.WriteCompactTag(7, cramberry.WireTypeV2Bytes)
		m.AppHash.EncodeTo(w)
	}
	if m.ConsensusHash != nil {
		w.WriteCompactTag(8, cramberry.WireTypeV2Bytes)
		m.ConsensusHash.EncodeTo(w)
	}
	if m.DagRound != 0 {
		w.WriteCompactTag(9, cramberry.WireTypeV2Varint)
		w.WriteUint64(m.DagRound)
	}
	if len(m.BatchCertRefs) > 0 {
		w.WriteCompactTag(10, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.BatchCertRefs)))
		for _, v := range m.BatchCertRefs {
			v.EncodeTo(w)
		}
	}
	w.WriteCompactTag(11, cramberry.WireTypeV2Bytes)
	m.Proposer.EncodeTo(w)
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlockHeader) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *BlockHeader) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.ChainId = r.ReadString()
		case 2:
			m.Height = r.ReadInt64()
		case 3:
			m.Time = r.ReadInt64()
		case 4:
			{
			var v Hash
			v.DecodeFrom(r)
			m.LastBlockHash = &v
		}
		case 5:
			{
			var v Hash
			v.DecodeFrom(r)
			m.LastCommitHash = &v
		}
		case 6:
			{
			var v Hash
			v.DecodeFrom(r)
			m.ValidatorsHash = &v
		}
		case 7:
			{
			var v Hash
			v.DecodeFrom(r)
			m.AppHash = &v
		}
		case 8:
			{
			var v Hash
			v.DecodeFrom(r)
			m.ConsensusHash = &v
		}
		case 9:
			m.DagRound = r.ReadUint64()
		case 10:
			n := int(r.ReadUvarint())
		m.BatchCertRefs = make([]BatchCertRef, n)
		for i := 0; i < n; i++ {
			m.BatchCertRefs[i].DecodeFrom(r)
		}
		case 11:
			m.Proposer.DecodeFrom(r)
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *BlockHeader) Validate() error {
	return nil
}


// BlockData contains the block body
type BlockData struct {
	// References to Looseberry batch certificates
BatchDigests []Hash `cramberry:"1" json:"batch_digests"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlockData) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *BlockData) EncodeTo(w *cramberry.Writer) {
	if len(m.BatchDigests) > 0 {
		w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.BatchDigests)))
		for _, v := range m.BatchDigests {
			v.EncodeTo(w)
		}
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *BlockData) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *BlockData) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			n := int(r.ReadUvarint())
		m.BatchDigests = make([]Hash, n)
		for i := 0; i < n; i++ {
			m.BatchDigests[i].DecodeFrom(r)
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}


// Block is a complete consensus block
type Block struct {
Header BlockHeader `cramberry:"1,required" json:"header"`
Data BlockData `cramberry:"2" json:"data"`
Evidence [][]byte `cramberry:"3" json:"evidence"`
LastCommit *Commit `cramberry:"4" json:"last_commit"`
}

// MarshalCramberry encodes the message to binary format using optimized V2 encoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Block) MarshalCramberry() ([]byte, error) {
	w := cramberry.GetWriter()
	defer cramberry.PutWriter(w)

	m.EncodeTo(w)

	if w.Err() != nil {
		return nil, w.Err()
	}
	return w.BytesCopy(), nil
}

// EncodeTo encodes the message directly to the writer using V2 format.
func (m *Block) EncodeTo(w *cramberry.Writer) {
	w.WriteCompactTag(1, cramberry.WireTypeV2Bytes)
	m.Header.EncodeTo(w)
	w.WriteCompactTag(2, cramberry.WireTypeV2Bytes)
	m.Data.EncodeTo(w)
	if len(m.Evidence) > 0 {
		w.WriteCompactTag(3, cramberry.WireTypeV2Bytes)
		w.WriteUvarint(uint64(len(m.Evidence)))
		for _, v := range m.Evidence {
			w.WriteBytes(v)
		}
	}
	if m.LastCommit != nil {
		w.WriteCompactTag(4, cramberry.WireTypeV2Bytes)
		m.LastCommit.EncodeTo(w)
	}
	w.WriteEndMarker()
}

// UnmarshalCramberry decodes the message from binary format using optimized V2 decoding.
// This method uses direct field access without reflection for maximum performance.
func (m *Block) UnmarshalCramberry(data []byte) error {
	r := cramberry.NewReaderWithOptions(data, cramberry.DefaultOptions)
	m.DecodeFrom(r)
	return r.Err()
}

// DecodeFrom decodes the message from the reader using V2 format.
func (m *Block) DecodeFrom(r *cramberry.Reader) {
	for {
		fieldNum, wireType := r.ReadCompactTag()
		if fieldNum == 0 {
			break
		}
		switch fieldNum {
		case 1:
			m.Header.DecodeFrom(r)
		case 2:
			m.Data.DecodeFrom(r)
		case 3:
			n := int(r.ReadUvarint())
		m.Evidence = make([][]byte, n)
		for i := 0; i < n; i++ {
			m.Evidence[i] = r.ReadBytes()
		}
		case 4:
			{
			var v Commit
			v.DecodeFrom(r)
			m.LastCommit = &v
		}
		default:
			// Skip unknown field for forward compatibility
			r.SkipValueV2(wireType)
		}
		if r.Err() != nil {
			return
		}
	}
}

// Validate validates that all required fields are set.
func (m *Block) Validate() error {
	return nil
}



